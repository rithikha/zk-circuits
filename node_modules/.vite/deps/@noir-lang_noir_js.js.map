{
  "version": 3,
  "sources": ["../../@noir-lang/noir_js/lib/base64_decode.mjs", "../../@noir-lang/noir_js/lib/witness_generation.mjs", "../../@noir-lang/noir_js/lib/program.mjs"],
  "sourcesContent": ["// Since this is a simple function, we can use feature detection to\n// see if we are in the nodeJs environment or the browser environment.\nexport function base64Decode(input) {\n    if (typeof Buffer !== 'undefined') {\n        // Node.js environment\n        return Buffer.from(input, 'base64');\n    }\n    else if (typeof atob === 'function') {\n        // Browser environment\n        return Uint8Array.from(atob(input), (c) => c.charCodeAt(0));\n    }\n    else {\n        throw new Error('No implementation found for base64 decoding.');\n    }\n}\n", "import { abiDecodeError, abiEncode } from '@noir-lang/noirc_abi';\nimport { base64Decode } from \"./base64_decode.mjs\";\nimport { executeProgram } from '@noir-lang/acvm_js';\nconst defaultForeignCallHandler = async (name, args) => {\n    if (name == 'print') {\n        // By default we do not print anything for `print` foreign calls due to a need for formatting,\n        // however we provide an empty response in order to not halt execution.\n        //\n        // If a user needs to print values then they should provide a custom foreign call handler.\n        return [];\n    }\n    throw Error(`Unexpected oracle during execution: ${name}(${args.join(', ')})`);\n};\nfunction parseErrorPayload(abi, originalError) {\n    const payload = originalError.rawAssertionPayload;\n    if (!payload)\n        return originalError;\n    const enrichedError = originalError;\n    try {\n        // Decode the payload\n        const decodedPayload = abiDecodeError(abi, payload);\n        if (typeof decodedPayload === 'string') {\n            // If it's a string, just add it to the error message\n            enrichedError.message = `Circuit execution failed: ${decodedPayload}`;\n        }\n        else {\n            // If not, attach the payload to the original error\n            enrichedError.decodedAssertionPayload = decodedPayload;\n        }\n    }\n    catch (_errorDecoding) {\n        // Ignore errors decoding the payload\n    }\n    return enrichedError;\n}\n// Generates the witnesses needed to feed into the chosen proving system\nexport async function generateWitness(compiledProgram, inputs, foreignCallHandler = defaultForeignCallHandler) {\n    // Throws on ABI encoding error\n    const witnessMap = abiEncode(compiledProgram.abi, inputs);\n    // Execute the circuit to generate the rest of the witnesses and serialize\n    // them into a Uint8Array.\n    try {\n        const solvedWitness = await executeProgram(base64Decode(compiledProgram.bytecode), witnessMap, foreignCallHandler);\n        return solvedWitness;\n    }\n    catch (err) {\n        // Typescript types catched errors as unknown or any, so we need to narrow its type to check if it has raw assertion payload.\n        if (typeof err === 'object' && err !== null && 'rawAssertionPayload' in err) {\n            throw parseErrorPayload(compiledProgram.abi, err);\n        }\n        throw new Error(`Circuit execution failed: ${err}`);\n    }\n}\n", "import { generateWitness } from \"./witness_generation.mjs\";\nimport initAbi, { abiDecode } from '@noir-lang/noirc_abi';\nimport initACVM, { compressWitnessStack } from '@noir-lang/acvm_js';\nexport class Noir {\n    circuit;\n    constructor(circuit) {\n        this.circuit = circuit;\n    }\n    /** @ignore */\n    async init() {\n        // If these are available, then we are in the\n        // web environment. For the node environment, this\n        // is a no-op.\n        if (typeof initAbi === 'function') {\n            await Promise.all([initAbi(), initACVM()]);\n        }\n    }\n    /**\n     * @description\n     * Allows to execute a circuit to get its witness and return value.\n     *\n     * @example\n     * ```typescript\n     * async execute(inputs)\n     * ```\n     */\n    async execute(inputs, foreignCallHandler) {\n        await this.init();\n        const witness_stack = await generateWitness(this.circuit, inputs, foreignCallHandler);\n        const main_witness = witness_stack[0].witness;\n        const { return_value: returnValue } = abiDecode(this.circuit.abi, main_witness);\n        return { witness: compressWitnessStack(witness_stack), returnValue };\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAEO,SAAS,aAAa,OAAO;AAChC,MAAI,OAAO,WAAW,aAAa;AAE/B,WAAO,OAAO,KAAK,OAAO,QAAQ;AAAA,EACtC,WACS,OAAO,SAAS,YAAY;AAEjC,WAAO,WAAW,KAAK,KAAK,KAAK,GAAG,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAAA,EAC9D,OACK;AACD,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAClE;AACJ;;;ACXA,IAAM,4BAA4B,OAAO,MAAM,SAAS;AACpD,MAAI,QAAQ,SAAS;AAKjB,WAAO,CAAC;AAAA,EACZ;AACA,QAAM,MAAM,uCAAuC,IAAI,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACjF;AACA,SAAS,kBAAkB,KAAK,eAAe;AAC3C,QAAM,UAAU,cAAc;AAC9B,MAAI,CAAC;AACD,WAAO;AACX,QAAM,gBAAgB;AACtB,MAAI;AAEA,UAAM,iBAAiB,eAAe,KAAK,OAAO;AAClD,QAAI,OAAO,mBAAmB,UAAU;AAEpC,oBAAc,UAAU,6BAA6B,cAAc;AAAA,IACvE,OACK;AAED,oBAAc,0BAA0B;AAAA,IAC5C;AAAA,EACJ,SACO,gBAAgB;AAAA,EAEvB;AACA,SAAO;AACX;AAEA,eAAsB,gBAAgB,iBAAiB,QAAQ,qBAAqB,2BAA2B;AAE3G,QAAM,aAAa,UAAU,gBAAgB,KAAK,MAAM;AAGxD,MAAI;AACA,UAAM,gBAAgB,MAAM,eAAe,aAAa,gBAAgB,QAAQ,GAAG,YAAY,kBAAkB;AACjH,WAAO;AAAA,EACX,SACO,KAAK;AAER,QAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,yBAAyB,KAAK;AACzE,YAAM,kBAAkB,gBAAgB,KAAK,GAAG;AAAA,IACpD;AACA,UAAM,IAAI,MAAM,6BAA6B,GAAG,EAAE;AAAA,EACtD;AACJ;;;ACjDO,IAAM,OAAN,MAAW;AAAA,EACd;AAAA,EACA,YAAY,SAAS;AACjB,SAAK,UAAU;AAAA,EACnB;AAAA;AAAA,EAEA,MAAM,OAAO;AAIT,QAAI,OAAO,2BAAY,YAAY;AAC/B,YAAM,QAAQ,IAAI,CAAC,uBAAQ,GAAG,gBAAS,CAAC,CAAC;AAAA,IAC7C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,QAAQ,QAAQ,oBAAoB;AACtC,UAAM,KAAK,KAAK;AAChB,UAAM,gBAAgB,MAAM,gBAAgB,KAAK,SAAS,QAAQ,kBAAkB;AACpF,UAAM,eAAe,cAAc,CAAC,EAAE;AACtC,UAAM,EAAE,cAAc,YAAY,IAAI,UAAU,KAAK,QAAQ,KAAK,YAAY;AAC9E,WAAO,EAAE,SAAS,qBAAqB,aAAa,GAAG,YAAY;AAAA,EACvE;AACJ;",
  "names": []
}
