import {
  abiDecode,
  abiDecodeError,
  abiEncode,
  noirc_abi_wasm_default,
  noirc_abi_wasm_exports
} from "./chunk-PIJNPDFK.js";
import {
  acvm_js_default,
  acvm_js_exports,
  and,
  blake2s256,
  compressWitnessStack,
  ecdsa_secp256k1_verify,
  ecdsa_secp256r1_verify,
  executeProgram,
  xor
} from "./chunk-SYF32QYC.js";
import "./chunk-NSBPE2FW.js";

// node_modules/@noir-lang/noir_js/lib/base64_decode.mjs
function base64Decode(input) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(input, "base64");
  } else if (typeof atob === "function") {
    return Uint8Array.from(atob(input), (c) => c.charCodeAt(0));
  } else {
    throw new Error("No implementation found for base64 decoding.");
  }
}

// node_modules/@noir-lang/noir_js/lib/witness_generation.mjs
var defaultForeignCallHandler = async (name, args) => {
  if (name == "print") {
    return [];
  }
  throw Error(`Unexpected oracle during execution: ${name}(${args.join(", ")})`);
};
function parseErrorPayload(abi, originalError) {
  const payload = originalError.rawAssertionPayload;
  if (!payload)
    return originalError;
  const enrichedError = originalError;
  try {
    const decodedPayload = abiDecodeError(abi, payload);
    if (typeof decodedPayload === "string") {
      enrichedError.message = `Circuit execution failed: ${decodedPayload}`;
    } else {
      enrichedError.decodedAssertionPayload = decodedPayload;
    }
  } catch (_errorDecoding) {
  }
  return enrichedError;
}
async function generateWitness(compiledProgram, inputs, foreignCallHandler = defaultForeignCallHandler) {
  const witnessMap = abiEncode(compiledProgram.abi, inputs);
  try {
    const solvedWitness = await executeProgram(base64Decode(compiledProgram.bytecode), witnessMap, foreignCallHandler);
    return solvedWitness;
  } catch (err) {
    if (typeof err === "object" && err !== null && "rawAssertionPayload" in err) {
      throw parseErrorPayload(compiledProgram.abi, err);
    }
    throw new Error(`Circuit execution failed: ${err}`);
  }
}

// node_modules/@noir-lang/noir_js/lib/program.mjs
var Noir = class {
  circuit;
  constructor(circuit) {
    this.circuit = circuit;
  }
  /** @ignore */
  async init() {
    if (typeof noirc_abi_wasm_default === "function") {
      await Promise.all([noirc_abi_wasm_default(), acvm_js_default()]);
    }
  }
  /**
   * @description
   * Allows to execute a circuit to get its witness and return value.
   *
   * @example
   * ```typescript
   * async execute(inputs)
   * ```
   */
  async execute(inputs, foreignCallHandler) {
    await this.init();
    const witness_stack = await generateWitness(this.circuit, inputs, foreignCallHandler);
    const main_witness = witness_stack[0].witness;
    const { return_value: returnValue } = abiDecode(this.circuit.abi, main_witness);
    return { witness: compressWitnessStack(witness_stack), returnValue };
  }
};
export {
  Noir,
  noirc_abi_wasm_exports as abi,
  acvm_js_exports as acvm,
  and,
  blake2s256,
  ecdsa_secp256k1_verify,
  ecdsa_secp256r1_verify,
  xor
};
//# sourceMappingURL=@noir-lang_noir_js.js.map
